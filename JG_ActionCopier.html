<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Joystick Gremlin Action Copier v2.3</title>
    <style>
    body { font-family: "Segoe UI", sans-serif; margin: 2em; background-color: #f0f0f0; }
    h1, h2, h3 { font-family: "Segoe UI Light", sans-serif; }
    .wizard-step { display: none; border: 1px solid #ccc; padding: 1.5em; background-color: #fff; margin-top: 1em; }
    #step1 { display: block; }
    .container { display: flex; gap: 2em; }
    .panel { flex: 1; border: 1px solid #ddd; padding: 1em; height: 60vh; overflow-y: auto; }
    ul { list-style-type: none; padding-left: 20px; }
    li { padding: 4px; }
    .selectable { cursor: pointer; }
    .selectable:hover { background-color: #e0e0e0; }
    .selected { background-color: #0078d4; color: white; }
    .parent-item { font-weight: bold; cursor: default; }
    .add-new-item { color: #006400; font-weight: bold; }
    .file-input-label { display: block; margin-bottom: 1em; }
    input[type="text"], input[type="file"] { width: 100%; padding: 8px; box-sizing: border-box; margin-bottom: 1em; }
    button { font-size: 1em; padding: 10px 15px; cursor: pointer; margin-right: 10px; background-color: #ddd; border: 1px solid #bbb; }
    button:hover { background-color: #ccc; }
    button:disabled { cursor: not-allowed; background-color: #eee; color: #aaa; }
    #actionsPanel, #logPanel { margin-top: 1em; padding: 1em; border: 1px solid #ccc; background-color: #f9f9f9; }
    .emoji-icon { font-family: "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji"; display: inline-block; width: 28px; text-align: center; }
    .description { color: #555; font-style: italic; }
    .selected .description { color: #eee; }
    #operationsLog { padding-left: 0; max-height: 150px; overflow-y: auto; background-color: #fff; border: 1px solid #ddd; padding: 10px; }
    .log-time { font-weight: bold; color: #005a9e; }
    #previewModal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 1000; }
    .modal-content { position: relative; background-color: #fff; margin: 5% auto; padding: 20px; width: 90%; max-width: 1800px; max-height: 80vh; overflow-y: auto; }
    .close-modal { position: absolute; top: 10px; right: 15px; font-size: 24px; font-weight: bold; cursor: pointer; }
    .preview-container { display: flex; gap: 20px; margin-top: 20px; }
    .preview-panel { flex: 1; border: 1px solid #ddd; padding: 15px; background-color: #f9f9f9; }
    .preview-panel pre { white-space: pre-wrap; font-family: monospace; font-size: 12px; max-height: 300px; overflow-y: auto; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; }
    .preview-summary { text-align: center; font-size: 1.2em; margin: 15px 0; padding: 10px; border: 1px solid; }
    .summary-add { background-color: #e8f5e9; color: #2e7d32; border-color: #a5d6a7; }
    .summary-replace { background-color: #fff3e0; color: #ef6c00; border-color: #ffcc80; }
    .preview-buttons { margin-top: 20px; text-align: center; }
    </style>
</head>
<body>

    <h1><span class="emoji-icon">üõ†Ô∏è</span> Joystick Gremlin Action Copier</h1>
    <p>A self-contained tool to copy actions between profiles with granular add/replace control.</p>

    <div id="step1" class="wizard-step">
        <h2><span class="emoji-icon">üìÇ</span> Step 1: Load Profiles</h2>
        <label class="file-input-label"><strong>1. Select Source Profile(s) (.xml):</strong></label>
        <input type="file" id="sourceFiles" multiple accept=".xml">
        <label class="file-input-label"><strong>2. Select Target Profile (.xml):</strong></label>
        <input type="file" id="targetFile" accept=".xml">
        <button id="loadFilesBtn"><span class="emoji-icon">‚ö°</span> Process Files</button>
    </div>

    <div id="step2" class="wizard-step">
        <h2><span class="emoji-icon">üå≥</span> Step 2: Copy & Paste Actions</h2>
        <div class="container">
            <div class="panel">
                <h3><span class="emoji-icon">üîç</span> Source Library</h3>
                <input type="text" id="searchSource" placeholder="Search profiles, devices, inputs...">
                <ul id="sourceTree"></ul>
            </div>
            <div class="panel">
                <h3><span class="emoji-icon">üéØ</span> Target Destinations</h3>
                <p id="targetInstruction">Select a source container to see destinations.</p>
                <ul id="targetTree"></ul>
            </div>
        </div>
        <div id="actionsPanel">
            <h3><span class="emoji-icon">‚úÖ</span> Step 3: Confirm & Save</h3>
            <p><strong>Selected Source:</strong> <span id="selectedSourceInfo">None</span></p>
            <p><strong>Selected Target:</strong> <span id="selectedTargetInfo">None</span></p>
            <button id="confirmCopyBtn" disabled>Preview Operation</button>
            <hr>
            <label for="outputFileName"><strong>Output Filename:</strong></label>
            <input type="text" id="outputFileName" disabled>
            <button id="saveBtn" disabled>Save Modified Profile</button>
            <button id="startOverBtn">Start Over</button>
        </div>
        <div id="logPanel">
            <h3><span class="emoji-icon">üìã</span> Operation Log</h3>
            <ul id="operationsLog"><li>No operations performed yet.</li></ul>
        </div>
    </div>
    
    <div id="previewModal">
        <div class="modal-content">
            <span class="close-modal">√ó</span>
            <h3><span class="emoji-icon">üëÅÔ∏è</span> Preview Operation</h3>
            <p id="previewSummary" class="preview-summary"></p>
            <div class="preview-container">
                <div class="preview-panel">
                    <h4>Source Content</h4>
                    <pre id="previewSourceXml"></pre>
                </div>
                <div class="preview-panel">
                    <h4 id="previewTargetHeader"></h4>
                    <pre id="previewTargetXml"></pre>
                </div>
            </div>
            <div class="preview-buttons">
                <button id="previewConfirmBtn">Confirm</button>
                <button id="previewCancelBtn">Cancel</button>
            </div>
        </div>
    </div>

<script>
// --- JAVASCRIPT APPLICATION LOGIC (v2.3 - Final) ---
const get = (id) => document.getElementById(id);
const step1 = get('step1'), step2 = get('step2');
const loadFilesBtn = get('loadFilesBtn'), sourceFilesInput = get('sourceFiles'), targetFileInput = get('targetFile');
const sourceTree = get('sourceTree'), targetTree = get('targetTree');
const searchSource = get('searchSource'), targetInstruction = get('targetInstruction');
const selectedSourceInfo = get('selectedSourceInfo'), selectedTargetInfo = get('selectedTargetInfo');
const confirmCopyBtn = get('confirmCopyBtn'), saveBtn = get('saveBtn'), startOverBtn = get('startOverBtn');
const outputFileName = get('outputFileName');
const operationsLog = get('operationsLog');
const previewModal = get('previewModal'), closeModal = document.querySelector('.close-modal');
const previewSummary = get('previewSummary'), previewSourceXml = get('previewSourceXml'), previewTargetXml = get('previewTargetXml');
const previewConfirmBtn = get('previewConfirmBtn'), previewCancelBtn = get('previewCancelBtn');
const previewTargetHeader = get('previewTargetHeader');

let sourceDOMs = {}, targetDOM = null, targetFileName = '';
let selectedSourceData = null, selectedTargetData = null;
let hasUnsavedChanges = false, logIsEmpty = true;
let pendingSourceContainer = null, pendingTargetParent = null;

function generateContainerDescription(container) {
    const actionSet = container.querySelector('action-set');
    if (!actionSet) return "Container (No Action Set)";
    const actions = Array.from(actionSet.children);
    if (actions.length === 0) return "Container (Empty)";
    return `Container: ${actions.map(a => a.tagName).join(', ')}`;
}

loadFilesBtn.addEventListener('click', () => {
    const sourceFiles = sourceFilesInput.files;
    const targetFile = targetFileInput.files[0];
    if (sourceFiles.length === 0 || !targetFile) { alert('Please select both source and target files.'); return; }
    sourceDOMs = {};
    let filesToProcess = sourceFiles.length + 1;
    const onFileProcessed = () => {
        if (--filesToProcess === 0) {
            buildSourceTreeView();
            step1.style.display = 'none';
            step2.style.display = 'block';
        }
    };
    Array.from(sourceFiles).forEach(file => {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const xmlDoc = new DOMParser().parseFromString(e.target.result, "application/xml");
                if (xmlDoc.querySelector("parsererror")) throw new Error(`Parser error in ${file.name}`);
                sourceDOMs[file.name] = xmlDoc;
                onFileProcessed();
            } catch (error) { alert(`Error: ${error.message}`); }
        };
        reader.readAsText(file);
    });
    const targetReader = new FileReader();
    targetReader.onload = (e) => {
        try {
            const xmlDoc = new DOMParser().parseFromString(e.target.result, "application/xml");
            if (xmlDoc.querySelector("parsererror")) throw new Error(`Parser error in ${targetFile.name}`);
            targetDOM = xmlDoc;
            targetFileName = targetFile.name;
            outputFileName.value = `${targetFile.name.replace(/\.xml$/, '')}_modified.xml`;
            onFileProcessed();
        } catch (error) { alert(`Error: ${error.message}`); }
    };
    targetReader.readAsText(targetFile);
});

/**
 * Creates a list item for the tree view.
 * @param {object} options - Configuration for the list item.
 * @returns {HTMLLIElement} The created list item element.
 */
function createListItem(options) {
    const li = document.createElement('li');
    li.innerHTML = `<span class="emoji-icon">${options.icon}</span><span class="${options.className || ''}">${options.text}</span>`;
    if (options.isSelectable) {
        li.classList.add('selectable');
        li.dataset.tree = options.treeType;
        li.dataset.info = JSON.stringify(options.data);
    }
    if (options.extraClass) li.classList.add(options.extraClass);
    return li;
}

/**
 * Recursively builds a branch of the tree.
 * @param {object} branchConfig - Configuration for the current branch.
 * @returns {HTMLLIElement|null} The list item for the branch, or null if it's empty and should be pruned.
 */
function buildBranch(branchConfig) {
    const node = createListItem(branchConfig.nodeOptions);
    const childrenData = branchConfig.getChildren();
    
    if (childrenData.length > 0) {
        const childList = document.createElement('ul');
        childrenData.forEach(childConfig => {
            const childNode = buildBranch(childConfig);
            if (childNode) { // Pruning: only append valid child branches
                childList.appendChild(childNode);
            }
        });
        if (childList.hasChildNodes()) {
            node.appendChild(childList);
        }
    }

    // A branch is valid if it's a selectable leaf, or a parent that contains a list of children.
    if (branchConfig.nodeOptions.isSelectable || node.querySelector('ul')) {
        return node;
    }
    return null;
}

/**
 * Builds the entire tree view for either the source or target panel.
 * This function defines the hierarchical structure and rules for building the tree.
 * @param {HTMLUListElement} rootUlElement - The <ul> element to populate (sourceTree or targetTree).
 * @param {object} docSet - The set of XML documents to parse (sourceDOMs or targetDOM).
 * @param {boolean} isSource - Flag indicating if this is the source tree.
 */
function buildTreeView(rootUlElement, docSet, isSource) {
    rootUlElement.innerHTML = '';
    const docs = isSource ? docSet : { [targetFileName]: docSet };
    
    Object.keys(docs).sort().forEach(filename => {
        const profileBranch = buildBranch({
            nodeOptions: { icon: 'üìÑ', text: filename, className: 'parent-item' },
            getChildren: () => Array.from(docs[filename].querySelectorAll('device')).map(device => ({
                nodeOptions: { icon: 'üéÆ', text: device.getAttribute('name') || 'Unnamed Device', className: 'parent-item' },
                getChildren: () => Array.from(device.querySelectorAll('mode > axis, mode > button')).map(element => ({
                    nodeOptions: {
                        icon: 'üéõÔ∏è',
                        text: (() => {
                            const type = element.tagName.charAt(0).toUpperCase() + element.tagName.slice(1);
                            const desc = element.getAttribute('description');
                            const numContainers = element.querySelectorAll(':scope > container').length;
                            return `${type} ${element.getAttribute('id')}${desc ? `: ${desc}` : ''} <span class="description">(${numContainers})</span>`;
                        })(),
                        className: 'parent-item'
                    },
                    getChildren: () => {
                        const containers = Array.from(element.querySelectorAll(':scope > container'));
                        if (isSource && containers.length === 0) return [];

                        const baseData = {
                            filename,
                            deviceGuid: element.closest('device').getAttribute('device-guid'),
                            type: element.tagName,
                            id: element.getAttribute('id')
                        };

                        const children = [];
                        if (!isSource) {
                            children.push({
                                nodeOptions: { icon: '‚ûï', text: '[Add as New Container]', isSelectable: true, treeType: 'target', data: { ...baseData, containerIndex: -1 }, extraClass: 'add-new-item' }
                            });
                        }
                        containers.forEach((container, index) => {
                            children.push({
                                nodeOptions: { icon: '‚Ü≥', text: generateContainerDescription(container), isSelectable: true, treeType: isSource ? 'source' : 'target', data: { ...baseData, containerIndex: index } }
                            });
                        });
                        return children.map(child => ({ ...child, getChildren: () => [] })); // Add base case for recursion
                    }
                }))
            }))
        });
        if (profileBranch) rootUlElement.appendChild(profileBranch);
    });
}

function buildSourceTreeView() { buildTreeView(sourceTree, sourceDOMs, true); }
function buildTargetSelectionView() {
    targetTree.innerHTML = '';
    targetInstruction.style.display = 'none';
    buildTreeView(targetTree, targetDOM, false);
}

document.addEventListener('click', (e) => {
    const selectable = e.target.closest('.selectable');
    if (!selectable) return;
    const treeType = selectable.dataset.tree;
    // UX BUG FIX: Correctly clear previous selection from the correct tree.
    document.querySelectorAll(`#${treeType}Tree .selected`).forEach(el => el.classList.remove('selected'));
    selectable.classList.add('selected');

    if (treeType === 'source') {
        selectedSourceData = JSON.parse(selectable.dataset.info);
        selectedTargetData = null; // Invalidate target on new source selection
        selectedSourceInfo.textContent = `Container ${selectedSourceData.containerIndex + 1} from ${selectedSourceData.type} ${selectedSourceData.id}`;
        selectedTargetInfo.textContent = 'None';
        confirmCopyBtn.disabled = true;
        buildTargetSelectionView();
    } else {
        selectedTargetData = JSON.parse(selectable.dataset.info);
        selectedTargetInfo.textContent = selectedTargetData.containerIndex === -1
            ? `Add to ${selectedTargetData.type} ${selectedTargetData.id}`
            : `Replace Container ${selectedTargetData.containerIndex + 1} on ${selectedTargetData.type} ${selectedTargetData.id}`;
        confirmCopyBtn.disabled = false;
    }
});

confirmCopyBtn.addEventListener('click', () => {
    const serializer = new XMLSerializer();
    const sourceParent = sourceDOMs[selectedSourceData.filename].querySelector(`device[device-guid="${selectedSourceData.deviceGuid}"] > mode > ${selectedSourceData.type}[id="${selectedSourceData.id}"]`);
    pendingSourceContainer = sourceParent.querySelectorAll(':scope > container')[selectedSourceData.containerIndex];
    pendingTargetParent = targetDOM.querySelector(`device[device-guid="${selectedTargetData.deviceGuid}"] > mode > ${selectedTargetData.type}[id="${selectedTargetData.id}"]`);
    
    previewSourceXml.textContent = serializer.serializeToString(pendingSourceContainer);

    if (selectedTargetData.containerIndex === -1) { // ADD
        previewSummary.className = 'preview-summary summary-add';
        previewSummary.textContent = `You are about to ADD this container.`;
        previewTargetHeader.textContent = `Target (All existing containers)`;
        let allTargetXml = Array.from(pendingTargetParent.querySelectorAll(':scope > container')).map(c => serializer.serializeToString(c)).join('\n\n');
        previewTargetXml.textContent = allTargetXml || 'Target is currently empty.';
    } else { // REPLACE
        const containerToReplace = pendingTargetParent.querySelectorAll(':scope > container')[selectedTargetData.containerIndex];
        previewSummary.className = 'preview-summary summary-replace';
        previewSummary.textContent = `You are about to REPLACE this target container.`;
        previewTargetHeader.textContent = `Target Container to be Replaced`;
        previewTargetXml.textContent = serializer.serializeToString(containerToReplace);
    }
    previewModal.style.display = 'block';
});

previewConfirmBtn.addEventListener('click', () => {
    const elementToInsert = pendingSourceContainer.cloneNode(true);
    const logAction = selectedTargetData.containerIndex === -1 ? 'ADD' : 'REPLACE';
    
    if (logAction === 'ADD') {
        pendingTargetParent.appendChild(elementToInsert);
    } else {
        const containerToReplace = pendingTargetParent.querySelectorAll(':scope > container')[selectedTargetData.containerIndex];
        pendingTargetParent.replaceChild(elementToInsert, containerToReplace);
    }

    addLogEntry(`[${logAction}] Container on ${selectedTargetData.type} ${selectedTargetData.id}.`);
    hasUnsavedChanges = true;
    saveBtn.disabled = false;
    outputFileName.disabled = false;
    
    // UX REFINEMENT: Refresh target tree for a smooth workflow, but clear target selection.
    buildTargetSelectionView();
    selectedTargetData = null;
    selectedTargetInfo.textContent = 'None';
    confirmCopyBtn.disabled = true;
    
    previewModal.style.display = 'none';
});

searchSource.addEventListener('input', (e) => {
    const searchTerm = e.target.value.toLowerCase();
    const allItems = Array.from(sourceTree.querySelectorAll('li'));
    if (!searchTerm) {
        allItems.forEach(li => li.style.display = '');
        return;
    }

    // Hide all items first
    allItems.forEach(li => { li.style.display = 'none'; li.dataset.keepVisible = 'false'; });

    // Find leaf nodes that match and mark them for visibility
    const leafItems = allItems.filter(li => li.classList.contains('selectable'));
    leafItems.forEach(li => {
        if (li.textContent.toLowerCase().includes(searchTerm)) {
            // Traverse up the tree from the match, marking all parents for visibility
            let current = li;
            while (current && current !== sourceTree) {
                current.dataset.keepVisible = 'true';
                current = current.parentElement.closest('li');
            }
        }
    });

    // Un-hide all items marked for visibility
    allItems.forEach(li => { if (li.dataset.keepVisible === 'true') { li.style.display = ''; }});
});

function addLogEntry(message) {
    if (logIsEmpty) { operationsLog.innerHTML = ''; logIsEmpty = false; }
    const logItem = document.createElement('li');
    logItem.innerHTML = `<span class="log-time">[${new Date().toLocaleTimeString()}]</span> ${message}`;
    operationsLog.prepend(logItem);
}

saveBtn.addEventListener('click', () => {
    const finalFileName = outputFileName.value.trim();
    if (!finalFileName) { alert('Output filename cannot be empty.'); return; }
    const xmlString = '<?xml version="1.0" encoding="utf-8"?>\n' + new XMLSerializer().serializeToString(targetDOM.documentElement);
    const blob = new Blob([xmlString], { type: 'application/xml' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = finalFileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
});

startOverBtn.addEventListener('click', () => window.location.reload());
previewCancelBtn.addEventListener('click', () => previewModal.style.display = 'none');
closeModal.addEventListener('click', () => previewModal.style.display = 'none');
</script>

</body>
</html>